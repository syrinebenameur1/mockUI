# Technical Interdependencies Between the Three Modules

## Overview

The KothonTech platform consists of three visually and functionally distinct modules that share a unified data architecture. While each module serves a specific purpose and user role, they are tightly integrated through a shared data model and consistent entity relationships.

## Technical Interdependencies

All three modules operate on a single, shared database schema where entities are referenced consistently across module boundaries. **Module 1 (Assessments & Matching)** creates and maintains the foundational data structures for `DeveloperProfile`, `Assessment`, `AssessmentResult`, `Tag`, `MatchingRequest`, and `MatchScore`. This data is not isolated to Module 1; it serves as the source of truth for talent information that flows into **Module 2 (Client & Dev Communication)** to determine project assignments, team composition, and availability tracking. The same developer profiles and assessment scores are consumed by **Module 3 (Operations)** to calculate utilization rates, billing rates, and performance KPIs.

**Module 2 (Client & Dev Communication)** depends on shared `Project`, `MessageThread`, `Message`, `FileResource`, and `AvailabilityEntry` entities. When a project is created (often originating from a successful match in Module 1), Module 2 uses the same `Project` ID to organize all communication, file sharing, calendar events, and Jira-style boards. The availability data tracked in Module 2 (vacation days, sick leave, reduced availability) directly impacts Module 3's financial calculations, as time tracking and invoicing must account for actual working hours versus planned capacity.

**Module 3 (Operations)** centralizes financial and operational data through `Invoice`, `Payment`, `TimeEntry`, `Expense`, `Subscription`, `Goal`, `KPIRecord`, and CRM entities (`CRMContact`, `CRMNote`). These entities reference the same `DeveloperProfile` and `Project` IDs established in Modules 1 and 2, creating a complete audit trail from initial candidate assessment through project delivery to final invoicing. For example, when Module 3 generates an invoice, it must reference the correct `projectId` (from Module 2) and `developerId` (from Module 1), ensuring data consistency across all three modules.

The interdependencies extend beyond simple foreign key relationships. When a client requests a talent in Module 1, the matching algorithm produces ranked candidates. Once a match is accepted and a project is created, Module 2 immediately inherits this project context for all communication and collaboration features. Module 3 then uses the project timeline and developer assignments to automate invoice generation, track expenses, and update CRM records. This means that any change in one module (e.g., a developer's availability update in Module 2) must propagate to Module 3's financial dashboards and utilization metrics in near real-time.

To maintain data integrity, all three modules must enforce consistent validation rules, permission models, and lifecycle management. For instance, when a project status changes from "Active" to "Completed" in Module 2, Module 3 must automatically trigger final invoicing workflows and update client history records. Similarly, when a developer's assessment score is updated in Module 1, Module 3's matching algorithms and CRM recommendations should reflect this change immediately.

In summary, the three modules are not independent applications but rather specialized views of a unified platform. They share a common data model, use consistent entity IDs, and maintain referential integrity through a shared database or a well-defined API layer that enforces these relationships. This architecture ensures that data created in one module is immediately available and actionable in the others, providing a seamless experience for users while maintaining a single source of truth for all business-critical information.
